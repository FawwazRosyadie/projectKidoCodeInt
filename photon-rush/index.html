<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photon Rush: Advanced Optics</title>
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff41;
            --neon-red: #ff3131;
            --bg-dark: #0a0a12;
            --glass: rgba(255, 255, 255, 0.1);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-dark);
            color: white;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* --- UI Overlay --- */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1200px;
            max-height: 800px;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 20px var(--neon-blue);
            display: flex;
            flex-direction: column;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            pointer-events: none;
        }

        .hud-panel {
            background: var(--glass);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            display: flex;
            gap: 20px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--neon-blue);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        #timer-bar-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 6px;
            background: #333;
        }

        #timer-bar {
            height: 100%;
            width: 100%;
            background: var(--neon-green);
            transition: width 0.1s linear, background 0.3s;
        }

        /* Canvas Area */
        #canvas-wrapper {
            flex-grow: 1;
            position: relative;
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Controls Area */
        #controls {
            height: 140px;
            background: rgba(0, 0, 0, 0.8);
            border-top: 1px solid var(--neon-blue);
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px;
            z-index: 20;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 50%;
        }

        input[type=range] {
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: var(--neon-blue);
            cursor: pointer;
            margin-top: -10px;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #555;
            border-radius: 2px;
        }

        button {
            background: rgba(0, 243, 255, 0.1);
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
            min-width: 180px;
        }

        button:hover {
            background: var(--neon-blue);
            color: black;
            box-shadow: 0 0 15px var(--neon-blue);
        }

        button:disabled {
            border-color: #555;
            color: #555;
            background: transparent;
            cursor: not-allowed;
            box-shadow: none;
        }

        button.active-concave {
            border-color: var(--neon-pink);
            color: var(--neon-pink);
            box-shadow: 0 0 10px var(--neon-pink) inset;
        }

        /* Screens */
        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 4rem;
            color: white;
            text-shadow: 0 0 20px var(--neon-blue), 4px 4px 0px var(--neon-pink);
            margin-bottom: 10px;
            text-align: center;
        }

        h2 {
            font-size: 2.5rem;
            color: var(--neon-green);
            margin-bottom: 20px;
        }

        p {
            font-size: 1.2rem;
            color: #ccc;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        .stars-display {
            font-size: 3rem;
            color: gold;
            margin-bottom: 20px;
            text-shadow: 0 0 10px orange;
        }

        .tutorial-tip {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--neon-green);
            padding: 15px 30px;
            color: var(--neon-green);
            font-weight: bold;
            font-size: 1.2rem;
            border-radius: 20px;
            animation: pulse 2s infinite;
            display: none;
            z-index: 50;
            text-align: center;
            pointer-events: none;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 255, 65, 0.4);
                transform: translateX(-50%) scale(1);
            }

            50% {
                box-shadow: 0 0 0 15px rgba(0, 255, 65, 0);
                transform: translateX(-50%) scale(1.05);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 255, 65, 0);
                transform: translateX(-50%) scale(1);
            }
        }

        #focus-lock-container {
            width: 100%;
            height: 20px;
            background: #222;
            border: 1px solid #555;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
            position: relative;
        }

        #focus-lock-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #00f3ff);
            transition: width 0.1s;
        }

        #focus-text {
            position: absolute;
            width: 100%;
            text-align: center;
            top: 0;
            font-size: 12px;
            font-weight: bold;
            color: white;
            line-height: 20px;
            text-shadow: 1px 1px 1px black;
        }

        .lens-badge {
            font-size: 0.8rem;
            margin-top: 5px;
            opacity: 0.8;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div id="timer-bar-container">
            <div id="timer-bar"></div>
        </div>

        <div id="hud">
            <div class="hud-panel">
                <div class="stat">
                    <span class="stat-label">Score</span>
                    <span id="score-val" class="stat-value">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Level</span>
                    <span id="level-val" class="stat-value">1</span>
                </div>
            </div>
            <div class="hud-panel">
                <div class="stat">
                    <span class="stat-label">Top Score</span>
                    <span id="high-score-val" class="stat-value">0</span>
                </div>
            </div>
        </div>

        <div id="tutorial-msg" class="tutorial-tip">Drag the slider to focus!</div>

        <div id="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
        </div>

        <div id="controls">
            <div style="text-align:center">
                <button id="btn-swap-lens">CONVEX LENS</button>
                <div id="lens-type-label" class="lens-badge">Converging</div>
            </div>

            <div class="control-group">
                <span style="color: var(--neon-blue); font-weight: bold; letter-spacing: 1px;">LENS POWER /
                    THICKNESS</span>
                <input type="range" id="focal-slider" min="20" max="300" value="100">
                <div id="focus-lock-container">
                    <div id="focus-text">IMAGE CLARITY</div>
                    <div id="focus-lock-bar"></div>
                </div>
            </div>
        </div>

        <div id="start-screen" class="overlay-screen">
            <h1>PHOTON RUSH</h1>
            <p><strong>MISSION:</strong> Manipulate light to form clear images.<br>
                You control the Focal Length (f) and Lens Type.<br>
                <br>
                <span style="color: var(--neon-green)">Real Image:</span> Forms on Sensor (Right).<br>
                <span style="color: var(--neon-pink)">Virtual Image:</span> Forms in Virtual Space (Left).
            </p>
            <button id="btn-start" style="font-size: 1.5rem; padding: 15px 40px;">Initialize Optics</button>
        </div>

        <div id="level-screen" class="overlay-screen hidden">
            <h2>FOCUS LOCKED!</h2>
            <div class="stars-display" id="level-stars">★★★</div>
            <p id="level-stats">Accuracy: 98% | Time Bonus: +500</p>
            <button id="btn-next-level">Next Challenge</button>
        </div>

        <div id="game-over-screen" class="overlay-screen hidden">
            <h2 style="color: var(--neon-red)">IMAGE BLURRED</h2>
            <p>The sensor failed to register a coherent image.</p>
            <div class="stat-value" id="final-score">0</div>
            <br>
            <button id="btn-restart">Reboot System</button>
        </div>

        <div id="victory-screen" class="overlay-screen hidden">
            <h1 style="color: var(--neon-green)">OPTICAL MASTER</h1>
            <div class="stars-display" id="total-stars">★★★★★</div>
            <p>You have mastered Convex and Concave lenses.</p>
            <div class="stat-value" id="victory-score">0</div>
            <br>
            <button id="btn-menu">Main Menu</button>
        </div>
    </div>

    <script>
        /**
         * PHOTON RUSH: ADVANCED OPTICS ENGINE
         */

        // --- Constants & Config ---
        const CONFIG = {
            canvasColor: '#000000',
            gridColor: '#1a1a2e',
            axisColor: '#444',
            lensColor: 'rgba(0, 243, 255, 0.2)',
            lensBorder: '#00f3ff',
            concaveBorder: '#ff00ff',
            objectColor: '#ffff00',
            imageColor: '#0066ff',
            virtualImageColor: '#00f3ff',
            rayColorDef: 'rgba(255, 255, 255, 0.3)',
            rayColorFocus: '#00ff41',
            rayColorBlur: '#ff3131',
            sensorColor: '#ff0055', // Real image target
            virtualTargetColor: '#00f3ff', // Virtual image target
            maxCharge: 100,
            chargeRate: 0.48,
            decayRate: 0.8,
        };

        // --- Game State ---
        const state = {
            screen: 'start',
            level: 1,
            score: 0,
            topScore: localStorage.getItem('photonRush_topScore') || 0,
            timer: 0,
            maxTime: 0,
            isPlaying: false,
            lastTime: 0,

            // Physics State
            objectDist: 200, // u (pixels from lens)
            objectHeight: 60,
            sensorDist: 200, // v (Target position). If negative, it's a Virtual Target.
            lensX: 0,
            focalLength: 100, // magnitude of f
            lensType: 'convex', // 'convex' or 'concave'

            // Mechanics
            focusCharge: 0,
            isFocused: false,
            imageDist: 0, // Calculated v
            magnification: 0,

            // Animation
            particles: []
        };

        // --- Level Design ---
        const LEVELS = [
            {
                id: 1,
                name: "Calibration",
                u: 200, v_target: 200,
                time: 30,
                moveObj: false,
                allowSwap: false,
                desc: "Drag the slider. Align the Blue Image with the Red Sensor."
            },
            {
                id: 2,
                name: "Distant Signal",
                u: 400, v_target: 140,
                time: 25,
                moveObj: false,
                allowSwap: false,
                desc: "Object is far away. Adjust focal length carefully."
            },
            {
                id: 3,
                name: "Short Sight",
                u: 200, v_target: -100, // Negative target = Virtual Image
                time: 40,
                moveObj: false,
                allowSwap: true,
                desc: "Target is Virtual (Left side). SWAP to a Concave Lens!"
            },
            {
                id: 4,
                name: "Dynamic Tracking",
                u: 250, v_target: 250,
                time: 35,
                moveObj: true,
                moveSpeed: 0.8,
                allowSwap: true,
                desc: "Object is moving. Maintain focus on the real sensor."
            },
            {
                id: 5,
                name: "Magnifying Glass",
                u: 80, v_target: -240, // u < f situation
                time: 30,
                moveObj: false,
                allowSwap: true,
                desc: "Create a magnified Virtual Image using a CONVEX lens (u < f)."
            },
            {
                id: 6,
                name: "Master Optician",
                u: 150, v_target: -100,
                time: 20,
                moveObj: true,
                moveSpeed: 1.5,
                allowSwap: true,
                desc: "Fast moving object. Virtual Target. Which lens works best?"
            }
        ];

        // --- Initialization ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let animationFrameId;

        function resize() {
            canvas.width = document.getElementById('canvas-wrapper').offsetWidth;
            canvas.height = document.getElementById('canvas-wrapper').offsetHeight;
            state.lensX = canvas.width / 2;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Input Handling ---
        const slider = document.getElementById('focal-slider');
        const btnStart = document.getElementById('btn-start');
        const btnNext = document.getElementById('btn-next-level');
        const btnRestart = document.getElementById('btn-restart');
        const btnMenu = document.getElementById('btn-menu');
        const btnSwap = document.getElementById('btn-swap-lens');
        const lblLens = document.getElementById('lens-type-label');

        slider.addEventListener('input', (e) => {
            state.focalLength = parseInt(e.target.value);
        });

        btnSwap.addEventListener('click', () => {
            if (state.lensType === 'convex') {
                state.lensType = 'concave';
                btnSwap.innerText = "CONCAVE LENS";
                btnSwap.classList.add('active-concave');
                lblLens.innerText = "Diverging (Virtual Images)";
                lblLens.style.color = "var(--neon-pink)";
            } else {
                state.lensType = 'convex';
                btnSwap.innerText = "CONVEX LENS";
                btnSwap.classList.remove('active-concave');
                lblLens.innerText = "Converging (Real & Virtual)";
                lblLens.style.color = "var(--neon-blue)";
            }
            // Create swap effect
            for (let i = 0; i < 20; i++) createParticle(state.lensX, canvas.height / 2, 'swap');
        });

        btnStart.addEventListener('click', () => startGame());
        btnNext.addEventListener('click', () => nextLevel());
        btnRestart.addEventListener('click', () => startGame());
        btnMenu.addEventListener('click', () => showScreen('start'));

        // --- Core Logic ---

        function showScreen(id) {
            document.querySelectorAll('.overlay-screen').forEach(el => el.classList.add('hidden'));
            if (id !== 'game') {
                document.getElementById(id + (id.includes('screen') ? '' : '-screen')).classList.remove('hidden');
            }
        }

        function startGame() {
            state.score = 0;
            state.level = 1;
            updateHUD();
            startLevel(1);
        }

        function startLevel(lvlNum) {
            const lvlConfig = LEVELS[lvlNum - 1];
            if (!lvlConfig) {
                finishGame();
                return;
            }

            state.level = lvlNum;
            state.screen = 'game';
            showScreen('game');

            // Reset Physics
            state.objectDist = lvlConfig.u;
            state.sensorDist = lvlConfig.v_target;
            state.maxTime = lvlConfig.time;
            state.timer = lvlConfig.time;
            state.focusCharge = 0;
            state.shakeIntensity = 0;

            // Lens Reset
            state.lensType = 'convex';
            btnSwap.innerText = "CONVEX LENS";
            btnSwap.classList.remove('active-concave');
            lblLens.innerText = "Converging";
            lblLens.style.color = "var(--neon-blue)";

            // Enable/Disable Swap
            btnSwap.disabled = !lvlConfig.allowSwap;
            if (!lvlConfig.allowSwap) btnSwap.style.opacity = "0.5";
            else btnSwap.style.opacity = "1";

            // Randomize initial slider to force interaction
            const randomStart = 50 + Math.random() * 200;
            state.focalLength = randomStart;
            slider.value = randomStart;

            // HUD Messages
            const tutMsg = document.getElementById('tutorial-msg');
            tutMsg.style.display = 'block';
            tutMsg.innerHTML = lvlConfig.desc;
            setTimeout(() => { tutMsg.style.display = 'none'; }, 6000);

            state.isPlaying = true;
            state.lastTime = performance.now();

            cancelAnimationFrame(animationFrameId);
            loop();
        }

        function nextLevel() {
            startLevel(state.level + 1);
        }

        function finishGame() {
            state.isPlaying = false;
            showScreen('victory');
            document.getElementById('victory-score').innerText = state.score;
            let stars = calculateStars(state.score, LEVELS.length * 1500);
            document.getElementById('total-stars').innerText = stars;
        }

        function gameOver() {
            state.isPlaying = false;
            showScreen('game-over');
            document.getElementById('final-score').innerText = state.score;
        }

        // --- Physics Engine ---

        function updatePhysics(dt) {
            const lvl = LEVELS[state.level - 1];

            // 1. Move Object
            if (lvl.moveObj) {
                const timeNow = Date.now() / 1000;
                const offset = Math.sin(timeNow * lvl.moveSpeed) * 40;
                state.objectDist = lvl.u + offset;
            }

            // 2. Determine Focal Length (Signed)
            // Convex: +f, Concave: -f
            let f = state.focalLength;
            if (state.lensType === 'concave') f = -f;

            // 3. Lens Formula: 1/v = 1/f - 1/u
            // u is always positive in this engine (distance left of lens)
            const val = (1 / f) - (1 / state.objectDist);

            if (val === 0) {
                state.imageDist = Infinity;
            } else {
                state.imageDist = 1 / val;
            }

            // 4. Magnification m = -v/u
            // If v is negative (Virtual), m is positive (Upright)
            state.magnification = -(state.imageDist / state.objectDist);

            // 5. Check Focus
            // We compare calculated v (state.imageDist) with target (state.sensorDist)
            // If Target is Virtual (negative), v must be negative and close.
            // If Target is Real (positive), v must be positive and close.

            const diff = Math.abs(state.imageDist - state.sensorDist);
            let tolerance = 15;

            // Special logic: Infinite
            if (Math.abs(state.imageDist) > 5000) state.isFocused = false;
            else state.isFocused = (diff < tolerance);

            // 6. Charge Logic
            if (state.isFocused) {
                state.focusCharge += CONFIG.chargeRate;
                if (state.focusCharge > CONFIG.maxCharge) state.focusCharge = CONFIG.maxCharge;
                if (Math.random() > 0.8) createParticle(state.lensX + state.sensorDist, canvas.height / 2, 'success');
            } else {
                state.focusCharge -= CONFIG.decayRate;
                if (state.focusCharge < 0) state.focusCharge = 0;
            }

            // 7. Timer & Win
            if (state.focusCharge >= CONFIG.maxCharge) levelComplete();

            state.timer -= dt;
            if (state.timer <= 0) gameOver();
        }

        function levelComplete() {
            state.isPlaying = false;
            const timeBonus = Math.floor(state.timer * 50);
            const lvlScore = 1000 + timeBonus;
            state.score += lvlScore;

            if (state.score > state.topScore) {
                state.topScore = state.score;
                localStorage.setItem('photonRush_topScore', state.topScore);
            }

            showScreen('level');
            document.getElementById('level-stats').innerText = `Time Remaining: ${state.timer.toFixed(1)}s | Bonus: +${timeBonus}`;
            document.getElementById('level-stars').innerText = calculateStars(lvlScore, 2000);
            updateHUD();
        }

        function calculateStars(score, maxRef) {
            const ratio = score / maxRef;
            if (ratio > 0.8) return "★★★";
            if (ratio > 0.5) return "★★";
            return "★";
        }

        function updateHUD() {
            document.getElementById('score-val').innerText = state.score;
            document.getElementById('level-val').innerText = state.level;
            document.getElementById('high-score-val').innerText = state.topScore;

            const timerPct = (state.timer / state.maxTime) * 100;
            const bar = document.getElementById('timer-bar');
            bar.style.width = `${Math.max(0, timerPct)}%`;

            if (timerPct < 30) bar.style.background = 'var(--neon-red)';
            else if (timerPct < 60) bar.style.background = 'orange';
            else bar.style.background = 'var(--neon-green)';

            const lockBar = document.getElementById('focus-lock-bar');
            lockBar.style.width = `${state.focusCharge}%`;

            // Text feedback on focus
            const focusText = document.getElementById('focus-text');
            if (state.isFocused) {
                focusText.innerText = "LOCKING FOCUS...";
                focusText.style.color = "#fff";
            } else {
                focusText.innerText = "ADJUST LENS";
                focusText.style.color = "#888";
            }
        }

        // --- Rendering ---

        function loop() {
            if (!state.isPlaying) return;

            const now = performance.now();
            const dt = (now - state.lastTime) / 1000;
            state.lastTime = now;

            updatePhysics(dt);
            updateHUD();
            render();

            animationFrameId = requestAnimationFrame(loop);
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background Grid
            drawGrid();

            const cy = canvas.height / 2;
            const lx = state.lensX;

            // 1. Optical Axis
            ctx.strokeStyle = CONFIG.axisColor;
            ctx.setLineDash([10, 10]);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(canvas.width, cy);
            ctx.stroke();
            ctx.setLineDash([]);

            // 2. Draw Sensor / Target
            // Check if target is Real (Right) or Virtual (Left)
            drawSensor(lx, cy);

            // 3. Draw Object (Arrow)
            const objX = lx - state.objectDist;
            const objH = state.objectHeight;
            drawArrow(objX, cy, objH, CONFIG.objectColor, "u", false);

            // 4. Draw Lens
            drawLens(lx, cy, state.focalLength, state.lensType);

            // 5. Draw Image & Rays
            // Math ensures state.imageDist is correct (signed)
            if (Math.abs(state.imageDist) < 5000) {
                const imgX = lx + state.imageDist;
                const imgH = objH * state.magnification;

                // Image Color
                const isVirtual = state.imageDist < 0;
                const imgColor = state.isFocused ? CONFIG.rayColorFocus : (isVirtual ? CONFIG.virtualImageColor : CONFIG.imageColor);

                // Draw Image Arrow
                ctx.globalAlpha = state.isFocused ? 1.0 : 0.6;
                drawArrow(imgX, cy, imgH, imgColor, "v", isVirtual);
                ctx.globalAlpha = 1.0;

                // Ray Tracing
                if (state.lensType === 'convex') {
                    drawConvexRays(objX, cy - objH, lx, cy, imgX, cy - imgH, state.isFocused);
                } else {
                    drawConcaveRays(objX, cy - objH, lx, cy, imgX, cy - imgH, state.isFocused);
                }
            }

            updateAndDrawParticles();
        }

        function drawSensor(lx, cy) {
            const isVirtualTarget = state.sensorDist < 0;
            const sensorX = lx + state.sensorDist;

            ctx.lineWidth = 4;

            if (isVirtualTarget) {
                // Virtual Target (Eye Focus Point)
                ctx.strokeStyle = CONFIG.virtualTargetColor;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(sensorX, cy - 60);
                ctx.lineTo(sensorX, cy + 60);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = CONFIG.virtualTargetColor;
                ctx.font = "12px Arial";
                ctx.fillText("VIRTUAL TARGET", sensorX - 40, cy - 70);
            } else {
                // Real Sensor
                ctx.strokeStyle = CONFIG.sensorColor;
                ctx.beginPath();
                ctx.moveTo(sensorX, cy - 80);
                ctx.lineTo(sensorX, cy + 80);
                ctx.stroke();

                ctx.fillStyle = CONFIG.sensorColor;
                ctx.font = "12px Arial";
                ctx.fillText("SENSOR", sensorX - 25, cy - 90);
            }
        }

        function drawGrid() {
            ctx.strokeStyle = CONFIG.gridColor;
            ctx.lineWidth = 1;
            const spacing = 50;
            for (let x = state.lensX % spacing; x < canvas.width; x += spacing) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        function drawArrow(x, y, height, color, label, isDashed) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 3;
            if (isDashed) ctx.setLineDash([5, 5]);

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y - height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Arrowhead
            ctx.beginPath();
            const headSize = 10;
            const dir = height > 0 ? -1 : 1;
            ctx.moveTo(x - headSize / 2, y - height + (headSize * dir));
            ctx.lineTo(x, y - height);
            ctx.lineTo(x + headSize / 2, y - height + (headSize * dir));
            ctx.fill();

            if (label) ctx.fillText(label, x - 10, y + 20);
        }

        function drawLens(x, y, f, type) {
            const height = 180;
            ctx.strokeStyle = type === 'convex' ? CONFIG.lensBorder : CONFIG.concaveBorder;
            ctx.fillStyle = CONFIG.lensColor;
            ctx.lineWidth = 3;

            ctx.beginPath();

            if (type === 'convex') {
                // Ellipse approximation
                const thickness = 60 - (f / 300) * 40;
                ctx.ellipse(x, y, thickness / 2, height / 2, 0, 0, 2 * Math.PI);
            } else {
                // Concave shape (Hourglass)
                const w = 40;
                const curve = 15;
                ctx.moveTo(x - w / 2, y - height / 2);
                ctx.lineTo(x + w / 2, y - height / 2);
                // Right side curve inward
                ctx.quadraticCurveTo(x, y, x + w / 2, y + height / 2);
                ctx.lineTo(x - w / 2, y + height / 2);
                // Left side curve inward
                ctx.quadraticCurveTo(x, y, x - w / 2, y - height / 2);
            }

            ctx.fill();
            ctx.stroke();

            // Mark Focal Points
            ctx.fillStyle = '#fff';
            ctx.font = "10px Arial";
            // F is on both sides
            ctx.beginPath(); ctx.arc(x - f, y, 3, 0, Math.PI * 2); ctx.fill();
            ctx.fillText("F", x - f - 5, y + 15);

            ctx.beginPath(); ctx.arc(x + f, y, 3, 0, Math.PI * 2); ctx.fill();
            ctx.fillText("F", x + f - 5, y + 15);
        }

        function drawConvexRays(ox, oy, lx, ly, ix, iy, isFocused) {
            const color = isFocused ? CONFIG.rayColorFocus : CONFIG.rayColorDef;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            // Ray 1: Parallel -> Refracts through Right Focus
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(lx, oy);
            ctx.lineTo(ix, iy);
            // Extend past image
            const slope1 = (iy - oy) / (ix - lx);
            ctx.lineTo(ix + 100, iy + 100 * slope1);
            ctx.stroke();

            // Ray 2: Center (Undeviated)
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(ix, iy);
            ctx.lineTo(ix + 100, iy + (iy - oy) / (ix - ox) * 100);
            ctx.stroke();

            // If virtual image (ix < lx), draw dotted tracebacks
            if (ix < lx) {
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = CONFIG.virtualImageColor;
                ctx.beginPath();
                ctx.moveTo(lx, oy); // From lens hit point
                ctx.lineTo(ix, iy); // Back to virtual image
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function drawConcaveRays(ox, oy, lx, ly, ix, iy, isFocused) {
            const color = isFocused ? CONFIG.rayColorFocus : CONFIG.rayColorDef;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            // Concave logic:
            // Ray 1: Parallel -> Diverges as if from Left Focus

            // Draw incident parallel
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(lx, oy);
            ctx.stroke();

            // Calculate divergence slope. It must align with Left Focal Point (lx - f, ly) and (lx, oy)
            // Left Focus X:
            const fx = lx - state.focalLength;
            const fy = ly;

            // Slope from F to Lens Hit
            const slope = (oy - fy) / (lx - fx);

            // Draw Diverging Ray (Solid) going Right
            ctx.beginPath();
            ctx.moveTo(lx, oy);
            ctx.lineTo(lx + 200, oy + 200 * slope);
            ctx.stroke();

            // Draw Virtual Traceback (Dashed) going Left to F
            ctx.setLineDash([4, 4]);
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.moveTo(lx, oy);
            ctx.lineTo(fx, fy);
            ctx.stroke();
            ctx.globalAlpha = 1.0;

            // Ray 2: Center (Undeviated)
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(lx + 200, ly + (ly - oy) * (-200 / state.objectDist));
            ctx.stroke();

            // Traceback to show image formation
            // The image forms where the traceback of Ray 1 intersects Ray 2
            // We already calculated ix, iy via math, so we can just draw lines to it to confirm visualization
        }

        // --- Particles ---
        function createParticle(x, y, type) {
            let color = '255, 255, 255';
            if (type === 'success') color = '0, 255, 65'; // Green
            if (type === 'swap') color = '0, 243, 255'; // Blue/Cyan

            state.particles.push({
                x: x + (Math.random() - 0.5) * 20,
                y: y + (Math.random() - 0.5) * 100,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5,
                life: 1.0,
                color: color
            });
        }

        function updateAndDrawParticles() {
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const p = state.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.03;

                if (p.life <= 0) {
                    state.particles.splice(i, 1);
                    continue;
                }

                ctx.fillStyle = `rgba(${p.color}, ${p.life})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

    </script>
</body>

</html>