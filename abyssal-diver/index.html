<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abyssal Diver: Pressure Plunge</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap');

        :root {
            --color-primary: #00f3ff;
            --color-secondary: #ff0055;
            --color-warning: #ffaa00;
            --color-bg-dark: #000913;
            --color-glass: rgba(255, 255, 255, 0.05);
            --color-glass-border: rgba(255, 255, 255, 0.1);
            --font-display: 'Orbitron', sans-serif;
            --font-body: 'Rajdhani', sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            cursor: default;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--color-bg-dark);
            background: radial-gradient(circle at center top, #0b2d42 0%, #000c18 60%, #000000 100%);
            color: white;
            font-family: var(--font-body);
            height: 100vh;
            width: 100vw;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-family: var(--font-display);
            font-size: 4rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            background: linear-gradient(180deg, #fff, var(--color-primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px var(--color-primary);
            margin-bottom: 1rem;
            text-align: center;
        }

        p {
            font-size: 1.5rem;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
            color: #ccc;
            margin-bottom: 2rem;
        }

        .btn {
            font-family: var(--font-display);
            font-size: 1.5rem;
            padding: 1rem 3rem;
            background: rgba(0, 243, 255, 0.1);
            border: 2px solid var(--color-primary);
            color: var(--color-primary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }

        .btn:hover {
            background: var(--color-primary);
            color: #000;
            box-shadow: 0 0 30px var(--color-primary);
            transform: scale(1.05);
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            background: var(--color-glass);
            border: 1px solid var(--color-glass-border);
            padding: 15px 25px;
            border-radius: 4px;
            /* Slight rounding */
            clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--color-primary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.2rem;
        }

        .stat-value {
            font-family: var(--font-display);
            font-size: 2rem;
            color: white;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .hud-bottom {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 20px;
            padding-bottom: 20px;
        }

        /* Gauges */
        .gauge-container {
            position: relative;
            width: 200px;
            height: 100px;
            /* Half circle */
            overflow: hidden;
            background: rgba(0, 0, 0, 0.5);
            border-top-left-radius: 100px;
            border-top-right-radius: 100px;
            border: 2px solid var(--color-glass-border);
            border-bottom: 0;
            display: flex;
            justify-content: center;
            align-items: flex-end;
        }

        .gauge-bg {
            position: absolute;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            border: 10px solid #333;
            top: 10px;
            border-bottom-color: transparent;
            border-left-color: transparent;
            /* For semi-circle effect logic, simpler to do via svg or css rotate */
        }

        /* Simpler Gauge Implementation */
        .gauge-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--color-glass);
            padding: 10px;
            border: 1px solid var(--color-glass-border);
            width: 220px;
        }

        .bar-container {
            width: 100%;
            height: 10px;
            background: #111;
            margin-top: 5px;
            position: relative;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            width: 0%;
            background: var(--color-primary);
            transition: width 0.2s;
            box-shadow: 0 0 10px var(--color-primary);
        }

        .bar-fill.warning {
            background: var(--color-warning);
            box-shadow: 0 0 10px var(--color-warning);
        }

        .bar-fill.danger {
            background: var(--color-secondary);
            box-shadow: 0 0 10px var(--color-secondary);
        }

        .gauge-label {
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-family: var(--font-display);
            font-size: 0.8rem;
            color: #aaa;
        }

        /* Physics Fact Popups */
        .fact-popup {
            position: absolute;
            top: 20%;
            right: 20px;
            width: 250px;
            background: rgba(0, 243, 255, 0.1);
            border-left: 4px solid var(--color-primary);
            padding: 15px;
            font-size: 0.9rem;
            line-height: 1.4;
            transform: translateX(300px);
            transition: transform 0.5s ease;
            backdrop-filter: blur(5px);
        }

        .fact-popup.active {
            transform: translateX(0);
        }

        /* Stars */
        .stars-container {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }

        .star {
            font-size: 3rem;
            color: #333;
            transition: color 0.5s, transform 0.5s;
        }

        .star.earned {
            color: #ffd700;
            filter: drop-shadow(0 0 15px #ffaa00);
            transform: scale(1.1);
        }

        /* Responsive Fixes */
        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }

            .hud-bottom {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <div id="hud">
            <div class="hud-top">
                <div class="hud-panel stat-group">
                    <span class="stat-label">Time Oxygen</span>
                    <span class="stat-value" id="hud-timer">00:00</span>
                </div>

                <div class="hud-panel stat-group" style="align-items: flex-end;">
                    <span class="stat-label">Score</span>
                    <span class="stat-value" id="hud-score">0000</span>
                    <span class="stat-label" style="font-size: 0.7rem; margin-top: 5px;">High: <span
                            id="hud-highscore">0</span></span>
                </div>
            </div>

            <div class="fact-popup" id="fact-popup">
                <strong style="color:var(--color-primary)">PRESSURE ALERT</strong><br>
                <span id="fact-text">Pressure increases by 1 atm for every 10m of depth!</span>
            </div>

            <div class="hud-bottom">
                <!-- Hull Integrity -->
                <div class="hud-panel gauge-box">
                    <div class="gauge-label">
                        <span>HULL INTEGRITY</span>
                        <span id="hull-text">100%</span>
                    </div>
                    <div class="bar-container">
                        <div class="bar-fill" id="hull-bar" style="width: 100%; background: var(--color-primary);">
                        </div>
                    </div>
                </div>

                <!-- Pressure Gauge -->
                <div class="hud-panel gauge-box" style="border-color: var(--color-secondary);">
                    <div class="gauge-label" style="color: var(--color-secondary);">
                        <span>EXTERNAL PRESSURE</span>
                        <span id="pressure-text">1 ATM</span>
                    </div>
                    <div class="bar-container">
                        <!-- Inverted bar logic visually, fills up as pressure rises -->
                        <div class="bar-fill danger" id="pressure-bar"
                            style="width: 0%; background: var(--color-secondary);"></div>
                    </div>
                </div>

                <!-- Depth -->
                <div class="hud-panel gauge-box">
                    <div class="gauge-label">
                        <span>CURRENT DEPTH</span>
                        <span id="depth-text">0 m</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="screen">
            <h1>ABYSSAL DIVER</h1>
            <p>
                Dive into the deep ocean to collect <strong>Data Pods</strong>.
                <br><br>
                Beware of <strong>Fluid Pressure</strong>. The deeper you go, the higher the pressure ($P = \rho g h$).
                If your hull integrity fails, the ocean will crush you.
                <br>
                <span style="font-size: 0.9em; color: var(--color-primary);">Controls: WASD or Arrow Keys to
                    Move.</span>
            </p>
            <button class="btn" id="start-btn">Initiate Dive</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen hidden">
            <h1 id="go-title">MISSION ABORTED</h1>
            <p id="go-reason">Hull Breach Detected.</p>

            <div class="stars-container">
                <div class="star" id="star-1">★</div>
                <div class="star" id="star-2">★</div>
                <div class="star" id="star-3">★</div>
            </div>

            <div class="stat-group" style="align-items: center; margin-bottom: 2rem;">
                <span class="stat-label">Final Score</span>
                <span class="stat-value" id="go-score">0</span>
            </div>

            <button class="btn" id="restart-btn">Re-Deploy</button>
        </div>
    </div>

    <script>
        /**
         * ABYSSAL DIVER - Interactive Science Minigame
         * Concepts: Pressure in Fluids, Depth relationship, Hull Stress
         */

        // --- Configuration ---
        const CONFIG = {
            gravity: 0.1,
            buoyancy: 0.15,
            drag: 0.98,
            speed: 0.5,
            maxSpeed: 6,
            surfaceLevel: 100, // Y position of surface
            maxDepth: 3000, // Virtual meters max logic
            pixelsPerMeter: 5, // scale
            pressurePerMeter: 0.1, // 1 atm surface, +1 every 10m approx
            basePressure: 1, // ATM
            hullMaxHealth: 100,
            gameDuration: 60, // seconds
            starThresholds: [1000, 3000, 5000]
        };

        // --- Game State ---
        const state = {
            isPlaying: false,
            score: 0,
            highScore: parseInt(localStorage.getItem('abyssal_highscore')) || 0,
            timeLeft: CONFIG.gameDuration,
            depth: 0, // meters
            pressure: 1, // atm
            hullHealth: 100,
            lastTime: 0,
            keys: { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false },
            objects: [],
            particles: [],
            camY: 0
        };

        // --- Asset Setup (Canvas Drawing Only) ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // Resize handling
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Input Handling ---
        window.addEventListener('keydown', e => {
            if (state.keys.hasOwnProperty(e.key) || state.keys.hasOwnProperty(e.code)) state.keys[e.key] = true;
        });
        window.addEventListener('keyup', e => {
            if (state.keys.hasOwnProperty(e.key) || state.keys.hasOwnProperty(e.code)) state.keys[e.key] = false;
        });

        // --- Classes ---

        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = 200;
                this.vx = 0;
                this.vy = 0;
                this.width = 60;
                this.height = 30;
                this.angle = 0;
            }

            update() {
                // Movement Forces
                if (state.keys['w'] || state.keys['ArrowUp']) this.vy -= CONFIG.speed;
                if (state.keys['s'] || state.keys['ArrowDown']) this.vy += CONFIG.speed;
                if (state.keys['a'] || state.keys['ArrowLeft']) this.vx -= CONFIG.speed;
                if (state.keys['d'] || state.keys['ArrowRight']) this.vx += CONFIG.speed;

                // Physics Model: Gravity vs Buoyancy
                // Submarine is slightly buoyant, needs force to dive deep quickly
                this.vy += CONFIG.gravity;
                this.vy -= (this.y > CONFIG.surfaceLevel) ? CONFIG.buoyancy : 0; // Only buoyant in water

                // Drag (Water Resistance)
                this.vx *= CONFIG.drag;
                this.vy *= CONFIG.drag;

                // Apply Velocity
                this.x += this.vx;
                this.y += this.vy;

                // Bounds
                if (this.x < 0) { this.x = 0; this.vx *= -0.5; }
                if (this.x > canvas.width) { this.x = canvas.width; this.vx *= -0.5; }
                if (this.y < 0) { this.y = 0; this.vy = 0; } // Sky bound

                // Calculate Depth & Pressure
                // Depth: distance below surface (100px)
                let rawDepthPixels = Math.max(0, this.y - CONFIG.surfaceLevel);
                state.depth = Math.floor(rawDepthPixels / CONFIG.pixelsPerMeter);
                state.pressure = CONFIG.basePressure + (state.depth * CONFIG.pressurePerMeter);

                // Hull Damage Logic
                // Safe pressure limit increases risk
                // Let's make it simpler: Pressure constantly applies "Stress". High pressure = faster stress if not careful.
                // Actually: Hit obstacles = damage. Deep depth = High Pressure Warning.
                // Game mechanic adjustment: Hitting walls/debris at high speed does damage.
                // Also, being VERY deep (> 400m) starts ticking damage slowly due to "Structural Fatigue"

                const CRITICAL_DEPTH = 300;
                if (state.depth > CRITICAL_DEPTH) {
                    // Damage scales with how deep past critical you are
                    const excess = state.depth - CRITICAL_DEPTH;
                    state.hullHealth -= (0.01 + (excess * 0.0001));

                    // Show warning
                    if (Math.random() < 0.05) createParticle(this.x, this.y, 'bubble');
                }

                // Rotation for effect
                this.angle = this.vx * 0.05;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Draw Submarine
                // Body
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Cockpit
                ctx.fillStyle = '#00f3ff';
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(10, -5, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;

                // Propeller
                if (state.isPlaying) {
                    ctx.fillStyle = '#444';
                    ctx.fillRect(-this.width / 2 - 5, -5, 5, 10);
                    // Spin effect
                    if (Date.now() % 100 < 50) {
                        ctx.fillStyle = '#666';
                        ctx.fillRect(-this.width / 2 - 8, -8, 2, 16);
                    }
                }

                // Lights
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#fff';
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(this.width / 2, 0);
                ctx.lineTo(this.width / 2 + 100, -30);
                ctx.lineTo(this.width / 2 + 100, 30);
                ctx.fill();
                // Actually let's use a constant gradient beam
                let g = ctx.createLinearGradient(0, 0, 150, 0);
                g.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                g.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(150, -40);
                ctx.lineTo(150, 40);
                ctx.fill();


                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        class Collectible {
            constructor(y) {
                this.x = Math.random() * canvas.width;
                this.y = y;
                this.size = 15;
                this.value = 100 + Math.floor(y / 10); // Deeper = more value
                this.collected = false;
                this.type = Math.random() > 0.8 ? 'gold' : 'data';
                this.oscillation = Math.random() * Math.PI;
            }

            update() {
                this.oscillation += 0.05;
                this.y += Math.sin(this.oscillation) * 0.2;
            }

            draw() {
                if (this.collected) return;
                ctx.save();
                ctx.translate(this.x, this.y);

                if (this.type === 'data') {
                    ctx.fillStyle = '#0f0';
                    ctx.shadowColor = '#0f0';
                } else {
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowColor = '#ffd700';
                }
                ctx.shadowBlur = 10;

                // Diamond shape
                ctx.beginPath();
                ctx.moveTo(0, -this.size);
                ctx.lineTo(this.size, 0);
                ctx.lineTo(0, this.size);
                ctx.lineTo(-this.size, 0);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }
        }

        class Debris {
            constructor(y) {
                this.x = Math.random() * canvas.width;
                this.y = y;
                this.size = 20 + Math.random() * 30;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = 0.5 + Math.random();
            }

            update() {
                this.y += this.vy;
                this.x += this.vx;
                // Sink slowly
                if (this.y > (state.depth * CONFIG.pixelsPerMeter) + canvas.height + 500) {
                    // Reset above view
                    this.y = state.camY - 100;
                    this.x = Math.random() * canvas.width;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = '#554433';
                ctx.beginPath();
                ctx.moveTo(0, -this.size / 2);
                ctx.lineTo(this.size / 2, this.size / 2);
                ctx.lineTo(-this.size / 2, this.size / 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = 1.0;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (type === 'bubble') ? -1 - Math.random() : (Math.random() - 0.5) * 5;
                this.size = Math.random() * 5;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
            }

            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = (this.type === 'bubble') ? 'rgba(255,255,255,0.5)' : '#ff5500';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        const player = new Player();

        // --- Systems ---

        function createParticle(x, y, type) {
            state.particles.push(new Particle(x, y, type));
        }

        function spawnLevel() {
            state.objects = [];
            // Create collectibles at various depths
            for (let i = 0; i < 30; i++) {
                // Depth from 200px to 5000px
                let d = 200 + Math.random() * 4000;
                state.objects.push(new Collectible(d));
            }

            // Create Debris obstacles
            for (let i = 0; i < 15; i++) {
                let d = 500 + Math.random() * 4000;
                state.objects.push(new Debris(d));
            }
        }

        function checkCollisions() {
            // Collectibles & Debris
            state.objects.forEach(obj => {
                if (obj instanceof Collectible && !obj.collected) {
                    const dist = Math.hypot(player.x - obj.x, player.y - obj.y);
                    if (dist < player.width / 2 + obj.size) {
                        obj.collected = true;
                        state.score += obj.value;
                        createParticle(obj.x, obj.y, 'sparkle');
                        // Audio placeholder
                    }
                } else if (obj instanceof Debris) {
                    const dist = Math.hypot(player.x - obj.x, player.y - obj.y);
                    if (dist < player.width / 2 + obj.size) {
                        // Collision
                        state.hullHealth -= 10;
                        obj.y += 100; // Bounce debris away visually
                        createParticle((player.x + obj.x) / 2, (player.y + obj.y) / 2, 'explosion');
                        // Knockback
                        player.vx = -player.vx * 2;
                        player.vy = -player.vy * 2;
                    }
                }
            });
        }

        function updateHUD() {
            document.getElementById('hud-timer').innerText = `00:${Math.max(0, Math.floor(state.timeLeft)).toString().padStart(2, '0')}`;
            document.getElementById('hud-score').innerText = state.score.toString().padStart(4, '0');
            document.getElementById('hud-highscore').innerText = state.highScore;

            document.getElementById('depth-text').innerText = state.depth + " m";

            let pressureVal = state.pressure.toFixed(1);
            document.getElementById('pressure-text').innerText = pressureVal + " ATM";

            // Gauge Fills
            // Hull
            const hullParams = document.getElementById('hull-bar');
            hullParams.style.width = Math.max(0, state.hullHealth) + "%";
            hullParams.className = state.hullHealth < 30 ? "bar-fill danger" : (state.hullHealth < 60 ? "bar-fill warning" : "bar-fill");
            document.getElementById('hull-text').innerText = Math.ceil(state.hullHealth) + "%";

            // Pressure Map (0 to 100% based on depth/maxDepth)
            // 300m = critical start. 
            const pressurePercent = Math.min(100, (state.depth / 600) * 100);
            document.getElementById('pressure-bar').style.width = pressurePercent + "%";

            // Show fact popup if deep
            const popup = document.getElementById('fact-popup');
            if (state.depth > 300 && !popup.classList.contains('active')) {
                popup.classList.add('active');
                document.getElementById('fact-text').innerText = "WARNING: DEPTH > 300m. Hull stress active due to extreme fluid pressure!";
            } else if (state.depth < 300 && popup.classList.contains('active')) {
                popup.classList.remove('active');
            }
        }

        // --- Game Loop ---
        function loop(timestamp) {
            if (!state.isPlaying) return;

            const dt = (timestamp - state.lastTime) / 1000;
            state.lastTime = timestamp;

            if (state.timeLeft > 0) {
                state.timeLeft -= (1 / 60); // approx
            } else {
                gameOver("Oxygen Depleted");
                return;
            }

            if (state.hullHealth <= 0) {
                gameOver("Hull Crush Depth Exceeded");
                return;
            }

            // Logic
            player.update();
            state.objects.forEach(o => o.update());
            state.particles.forEach((p, i) => {
                p.update();
                if (p.life <= 0) state.particles.splice(i, 1);
            });

            checkCollisions();
            updateHUD();

            // Camera Follow Y
            // Trying to keep player in middle of Y
            let targetCamY = player.y - canvas.height / 2;
            // Clamp cam so we don't see above sky too much
            if (targetCamY < -100) targetCamY = -100;
            state.camY = targetCamY; // Instant follow for stiffness, or lerp for smooth

            // Drawing
            // Clear
            ctx.fillStyle = '#000'; // BG handled by CSS? No, we need to clear or draw semi-transparent for trails?
            // CSS handles the gradient background. We just clearRect.
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            // Background water reference lines (grid)
            ctx.translate(0, -state.camY);

            // Draw water surface
            ctx.fillStyle = 'rgba(0, 243, 255, 0.1)';
            ctx.fillRect(0, CONFIG.surfaceLevel, canvas.width, canvas.height + 5000); // Massive fill

            // Draw Depth markers
            ctx.font = '12px Rajdhani';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            for (let d = 0; d < 1000; d += 50) {
                let yPos = CONFIG.surfaceLevel + (d * CONFIG.pixelsPerMeter);
                if (yPos > state.camY - 50 && yPos < state.camY + canvas.height + 50) {
                    ctx.fillText(`- ${d}m -`, 50, yPos);
                    ctx.fillRect(0, yPos, 40, 1);
                }
            }

            // Objects
            state.objects.forEach(o => o.draw());
            state.particles.forEach(p => p.draw());
            player.draw();

            ctx.restore();

            requestAnimationFrame(loop);
        }

        // --- Control Flow ---
        function startGame() {
            state.score = 0;
            state.hullHealth = 100;
            state.timeLeft = CONFIG.gameDuration;
            state.depth = 0;
            state.pressure = 1;
            state.isPlaying = true;
            state.lastTime = performance.now();
            state.particles = [];

            // Reset player
            player.x = canvas.width / 2;
            player.y = 100; // Surface
            player.vx = 0;
            player.vy = 0;

            spawnLevel();

            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            requestAnimationFrame(loop);
        }

        function gameOver(reason) {
            state.isPlaying = false;
            if (state.score > state.highScore) {
                state.highScore = state.score;
                localStorage.setItem('abyssal_highscore', state.highScore);
            }

            // Calculate Stars
            const s = state.score;
            const stars = [
                document.getElementById('star-1'),
                document.getElementById('star-2'),
                document.getElementById('star-3')
            ];
            stars.forEach(star => star.classList.remove('earned'));

            if (s >= CONFIG.starThresholds[0]) stars[0].classList.add('earned');
            if (s >= CONFIG.starThresholds[1]) stars[1].classList.add('earned');
            if (s >= CONFIG.starThresholds[2]) stars[2].classList.add('earned');

            document.getElementById('go-title').innerText = reason === "Win" ? "MISSION COMPLETE" : "MISSION FAILED";
            document.getElementById('go-reason').innerText = reason;
            document.getElementById('go-score').innerText = state.score;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);

        // Initial Render call to clear canvas
        resize();

    </script>
</body>

</html>